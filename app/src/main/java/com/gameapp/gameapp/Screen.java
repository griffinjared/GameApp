package com.gameapp.gameapp;

import android.app.Activity;
import android.content.Context;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.util.Log;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;

import java.util.List;

import gameapp.framework.Input.TouchEvent;
import levels.Level;
import levels.Level_1_Forest;
import mob.Player;

/** The Screen class used to be called "gameClass"
 *  Instead, it is now the graphics portion of the Game and only the graphics portion
 *  Since it extends SurfaceView, the Screen is nothing but a layer of graphics that is put over the Game Class
 *  Once the Screen is generated by the Game class, the MainThread is generated by the Screen class's constructor
 *  The onDraw method is where all graphics are rendered
 *  The update method is where all the game's numbers are updated every frame
 *  onDraw and update are both repeatedly called by the the MainThread every frame
 */

public class Screen extends SurfaceView implements SurfaceHolder.Callback {

    private static final String TAG = Screen.class.getSimpleName();

    //Primary Components
    private MainThread thread;
    private SeedGenerator seeder;
    private Level level; //one instant of the level can be used for all levels
    private Player player; //the only playable and controllable character on-screen

    public static final int SIZE = 288; //Dimensions of one regular room

    public Screen(Context context) {
        super(context);
        getHolder().addCallback(this);

        //create the game loop thread
        thread = new MainThread(getHolder(), this);

        //Game components
        seeder = new SeedGenerator();
        level = new Level_1_Forest(getContext(), 1, BitmapFactory.decodeResource(getResources(), R.drawable.tiles_level1_forest));
        player = new Player(3, 3, getResources());

        setFocusable(true);

        setBackgroundColor(Color.LTGRAY);
    }

    @Override
    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {

    }

    @Override
    public void surfaceCreated(SurfaceHolder holder) {
        thread.setRunning(true);
        thread.start();
    }

    @Override
    public void surfaceDestroyed(SurfaceHolder holder) {
        boolean retry = true;
        while (retry) {
            try {
                thread.join();
                retry = false;
            } catch (InterruptedException e) {
                //try again shutting down the thread
            }
        }
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if(event.getAction() == MotionEvent.ACTION_DOWN) {
            if(event.getY() > getHeight() - 50) {
                thread.setRunning(false);
                ((Activity)getContext()).finish();
            } else {
                Log.d(TAG, "Coords: x=" + event.getX() + ",y=" + event.getY());
            }
        }
        return super.onTouchEvent(event);
    }

    public void update() {
        // TODO: implement game states
    }

    public void updateRunning(List touchEvents, float deltaTime) {
        int len = touchEvents.size();

        for (int i = 0; i < len; i++) {
            TouchEvent event = (TouchEvent) touchEvents.get(i);
            if (event.type == TouchEvent.TOUCH_DOWN) { // user touched screen
                // TODO: implement touch events
            }

            if (event.type == TouchEvent.TOUCH_UP) { // user stopped touching screen
                // TODO: implement touch stopped events
            }

            // TOUCH_DRAGGED and TOUCH_HOLD are also included
        }
    }

    private boolean inBounds(TouchEvent event, int x, int y, int width, int height) {
        //this checks if the touchEvent passed occurred within the specified pixel bounds
        return (event.x > x && event.x < x + width - 1 && event.y > y && event.y < y + height - 1);
    }

    @Override
    /** The Paint class can probably used for any on-screen text.
     *  It cannot however, draw complex graphics and is limited to text and simple shapes like circles and rectangles
     */
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        Paint paint = new Paint();

        /** What happens right here is the scaling process so that the game is always scaled adequately to the screen size
         *  The standard size of a room is 288 pixels (12 tiles * 24 pixels each)
         *  The canvas is scaled up the proper amount so that the length of the room is equal to the width of the screen
         *  (or height of the screen if the game is landscape instead)
         * */

        int w = getWidth(); int h = getHeight();

        paint.setTextSize(20);
        paint.setColor(Color.RED);
        paint.setTextAlign(Paint.Align.CENTER);

        //Adjust scale to screen size
        float scaleFactor = ((w * 1.00f) / (SIZE * 1.00f)); //Portrait

        int saveState = canvas.save();
        canvas.scale(scaleFactor, scaleFactor);

        //Tiles
        for (int y = 0; y < level.getCurrentRoom().getTileLayout().length; y++) {
            for (int x = 0; x < level.getCurrentRoom().getTileLayout()[y].length; x++) {
                switch(level.getCurrentRoom().getTileLayout()[y][x]) {
                    case 0: Level.Floor0.draw(canvas, paint, x, y); break;
                    case 1: Level.Wall.draw(canvas, paint, x, y); break;
                }
            }
        }

        //Player, Mobs, and Enemies
        player.draw(canvas, paint);

        canvas.restoreToCount(saveState); //canvas has to be scaled back down to size

        //HUD, UI, and On-Screen Text
        canvas.drawText("UI", w/2, w + paint.getTextSize(), paint);
    }
}
